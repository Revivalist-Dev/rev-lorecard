### **System Design: AI Lorebook Generator**

#### **1. Overview**

This document outlines the architecture for an application designed to automate the creation of structured "lorebooks" from web-based sources. The system leverages Large Language Models (LLMs) to intelligently generate search criteria, parse web pages, extract relevant information, and summarize it into a usable format for creative writing or AI roleplaying applications. The core process is a user-guided, four-stage workflow: Search Parameter Generation, Selector Generation, Link Extraction, and Entry Generation.

*   **Language:** Python
*   **Package Manager:** `uv`
*   **API framework:** Litestar
*   **Database:** SQL (PostgreSQL recommended for JSONB support). No ORM.
*   **Model validation:** Pydantic
*   **Web Scraping:** `BeautifulSoup4` for HTML parsing.
*   **Template framework:** Jinja for prompt templating.

#### **2. Core Entities & Data Models**

##### **2.1. `Project`**

*   **Purpose**: A `Project` is the primary organizational unit, representing a single lorebook generation task. It encapsulates all configuration, source data, and results for creating one lorebook.

*   **Fields**:
    *   `id` (Text, Primary Key): A unique, human-readable identifier, derived from the project name (e.g., "skyrim-locations").
    *   `name` (Text): The user-friendly display name of the project (e.g., "Skyrim Locations Lorebook").
    *   `source_url` (Text): The initial Fandom/Wiki category URL provided by the user to start the process.
    *   `prompt` (Text, nullable): The high-level user-provided prompt to generate search parameters (e.g., "Skyrim locations").
    *   `search_params` (JSONB, nullable): Structured search parameters generated by an LLM (`purpose`, `extraction_notes`, `criteria`).
    *   `link_extraction_selector` (List of Text, nullable): A list of CSS selectors used to identify and extract individual article links from the `source_url`. This is generated by an LLM and confirmed by the user.
    *   `templates` (JSONB): A structured object containing all Jinja prompt templates for the project's tasks.
        *   `selector_generation` (Text): The prompt used to instruct an LLM to analyze HTML and return CSS selectors.
        *   `entry_creation` (Text): The prompt used to instruct an LLM to process a scraped web page into a structured lorebook entry.
        *   `search_params_generation` (Text): The prompt used to instruct an LLM to generate search parameters from a user prompt.
    *   `ai_provider_config` (JSONB): A structured object containing all necessary information to interact with the LLM API (e.g., `api_provider`, `model_name`, `model_parameters`).
    *   `requests_per_minute` (Integer): The maximum number of API requests to make per minute for this project, used for rate limiting.
    *   `status` (Enum): The current high-level state of the project (`draft`, `selector_generated`, `links_extracted`, `processing`, `completed`, `failed`).
    *   `created_at` (Timestamp with Timezone): The timestamp when the project was created.
    *   `updated_at` (Timestamp with Timezone): The timestamp when the project was last updated.

---

##### **2.2. `Link`**

*   **Purpose**: Represents a single URL selected by the user for processing. Each `Link` is an atomic unit of work waiting to be processed into a `LorebookEntry`.

*   **Fields**:
    *   `id` (UUID, Primary Key): A unique, system-generated identifier for internal use.
    *   `project_id` (Text, Foreign Key): Links the `Link` to its parent `Project`.
    *   `url` (Text): The full, absolute URL of the page to be processed.
    *   `status` (Enum): The current lifecycle state (`pending`, `processing`, `completed`, `failed`).
    *   `error_message` (Text, nullable): Stores the error details if processing fails for this specific link.
    *   `lorebook_entry_id` (UUID, Foreign Key, nullable): A reference to the final `LorebookEntry` that was created from this link.
    *   `raw_content` (Text, nullable): The raw text content scraped from the source URL. Caching this allows for reprocessing with a new prompt without needing to re-scrape the page.
    *   `created_at` (Timestamp with Timezone): The timestamp when the link was extracted.

---

##### **2.3. `LorebookEntry`**

*   **Purpose**: The final, structured output of the generation process. It represents a single, self-contained piece of lore ready for use.

*   **Fields**:
    *   `id` (UUID, Primary Key): A unique identifier for the lorebook entry.
    *   `project_id` (Text, Foreign Key): Links the entry to the `Project` it belongs to.
    *   `title` (Text): The main title of the lore entry, as generated by the LLM.
    *   `content` (Text): The summarized body of the lore entry.
    *   `keywords` (List of Text, JSONB): A list of keywords, generated by the LLM, that can be used to trigger this entry in a roleplay application.
    *   `source_url` (Text): The original URL from which the entry's content was derived, for traceability.
    *   `created_at` (Timestamp with Timezone): The timestamp when the entry was created.
    *   `updated_at` (Timestamp with Timezone): The timestamp when the entry was last updated (e.g., by a user).

---

##### **2.4. `BackgroundJob`**

*   **Purpose**: Represents a single asynchronous task executed by a background worker. This table serves as a robust, database-backed task queue.

*   **Fields**:
    *   `id` (UUID, Primary Key): A unique identifier for the job.
    *   `task_name` (Text): The name of the task to be executed (e.g., `generate_search_params`, `generate_selector`, `extract_links`, `process_project_entries`).
    *   `payload` (JSONB, nullable): Additional arguments required for the task.
    *   `status` (Enum): The job's state (`pending`, `in_progress`, `completed`, `failed`, `cancelling`, `canceled`).
    *   `project_id` (Text, Foreign Key, nullable): Links the job to the `Project` it operates on.
    *   `created_at` / `updated_at` (Timestamp with Timezone): Timestamps for job lifecycle tracking.
    *   `result` (JSONB): The result of the job if successful.
    *   `error_message` (Text): Error details if the job failed.
    *   `total_items` (Integer, nullable): The total number of items to be processed (e.g., number of links found).
    *   `processed_items` (Integer, nullable): The number of items processed so far.
    *   `progress` (Real, nullable): The completion percentage (0.0 to 100.0).

---

##### **2.5. `ApiRequestLog`**

*   **Purpose**: An immutable audit record of every billable call made to an external LLM API, essential for cost tracking, performance analysis, and detailed debugging.

*   **Fields**:
    *   `id` (UUID, Primary Key): A unique identifier for the log record.
    *   `project_id` (Text, Foreign Key): Links the request back to the project for cost aggregation.
    *   `job_id` (UUID, Foreign Key, nullable): Links the log to the `BackgroundJob` that initiated it.
    *   `api_provider` (Text): The API provider used (e.g., "openrouter").
    *   `model_used` (Text): The exact model string used for the call.
    *   `request` (JSONB): The full request payload sent to the API.
    *   `response` (JSONB, nullable): The full response payload received from the API.
    *   `input_tokens` / `output_tokens` (Integer, nullable): Token usage metrics.
    *   `calculated_cost` (Numeric, nullable): The monetary cost of the API call.
    *   `latency_ms` (Integer): The duration of the API call in milliseconds.
    *   `timestamp` (Timestamp with Timezone): The exact time the request was made.
    *   `error` (Boolean): A flag indicating if the API call resulted in an error.

---

##### **2.6. `GlobalTemplate`**

*   **Purpose**: Stores reusable Jinja prompt templates that can be referenced by any `Project`. This allows for a centralized library of prompts that can be maintained independently from individual projects.

*   **Fields**:
    *   `id` (Text, Primary Key): A unique, human-readable identifier for the template (e.g., "default-selector-prompt").
    *   `name` (Text, Unique): A user-friendly, unique name for the template (e.g., "Default Selector Prompt").
    *   `content` (Text): The full Jinja template string.
    *   `created_at` / `updated_at` (Timestamp with Timezone): Timestamps for template lifecycle tracking.

---

##### **2.7. Database Schema & Relationships**

*   **Relationships**:
    *   `Link.project_id` -> `Project.id` (Many-to-One). `ON DELETE CASCADE`.
    *   `LorebookEntry.project_id` -> `Project.id` (Many-to-One). `ON DELETE CASCADE`.
    *   `Link.lorebook_entry_id` -> `LorebookEntry.id` (One-to-One, nullable). `ON DELETE SET NULL`.
    *   `BackgroundJob.project_id` -> `Project.id` (Many-to-One). `ON DELETE CASCADE`.
    *   `ApiRequestLog.project_id` -> `Project.id` (Many-to-One). `ON DELETE CASCADE`.
    *   `ApiRequestLog.job_id` -> `BackgroundJob.id` (Many-to-One). `ON DELETE SET NULL`.

*   **Indexing Strategy**:
    *   `Project`: Index on `id` (Primary Key).
    *   `Link`:
        *   Index on `(project_id, status)` for efficient querying of pending links by workers.
        *   Unique constraint on `(project_id, url)` to prevent duplicate link processing.
    *   `LorebookEntry`: Index on `project_id` for efficient retrieval of a project's entries.
    *   `BackgroundJob`: Index on `(status, created_at)` for efficient polling by workers.
    *   `ApiRequestLog`: Index on `project_id` for cost aggregation.
    *   `GlobalTemplate`: Index on `id` (Primary Key), Unique constraint on `name`.

#### **3. Core Workflows**

##### **3.1. Workflow A: Project Setup & Search Parameter Generation**

1.  **Project Creation**: A user creates a new `Project` by providing a `name`, `source_url`, and a high-level `prompt` (e.g., "Characters from Skyrim"). The project's initial `status` is `draft`.
2.  **Job Invocation**: The user initiates the first step via the API, which creates a `BackgroundJob` with `task_name: 'generate_search_params'`.
3.  **Worker Execution**: A background worker picks up the job.
    *   It constructs a prompt using the `templates.search_params_generation` template and the project's `prompt`.
    *   It sends the prompt to the configured LLM, asking for a structured JSON response containing `purpose`, `extraction_notes`, and `criteria`.
    *   It creates an `ApiRequestLog` to record this transaction.
    *   Upon receiving a valid response, the worker updates the `Project.search_params` field in the database.
    *   Finally, it marks the job as `completed`.

##### **3.2. Workflow B: Selector Generation & User Confirmation**

1.  **Job Invocation**: Following the generation of search parameters, the user initiates this step. This creates a `BackgroundJob` with `task_name: 'generate_selector'`.
2.  **Worker Execution**: A background worker picks up the job.
    *   It scrapes the raw HTML from the project's `source_url`.
    *   It constructs a detailed prompt using the `templates.selector_generation` template, including the scraped HTML and the structured `search_params` from the previous step.
    *   It sends the prompt to the LLM, asking for a list of CSS selectors that target article links.
    *   It creates an `ApiRequestLog` for this call.
    *   Upon receiving a valid response, the worker updates the `Project.link_extraction_selector` field with the list of selectors.
    *   It updates the `Project.status` to `selector_generated` and marks the job as `completed`.
3.  **User Confirmation**: The frontend displays the `source_url` page and uses the generated selectors to highlight the targeted link elements. The user can visually confirm the selection, de-select any incorrect links, and then submits the final, curated list of URLs to the next workflow.

##### **3.3. Workflow C: Link Extraction**

1.  **Job Invocation**: After the user confirms the desired links on the frontend, the client sends this list of URLs to the backend, creating a `BackgroundJob` with `task_name: 'extract_links'`.
2.  **Worker Execution**: A background worker picks up the job.
    *   It reads the list of URLs from the job's `payload`.
    *   For each URL, it creates a new `Link` record in the database with `status: 'pending'`. It enforces the unique constraint to avoid duplicates.
    *   Upon completion, it updates the `Project.status` to `links_extracted` and marks the job as `completed`.

##### **3.4. Workflow D: Lorebook Entry Generation**

1.  **Job Invocation**: The user starts the main generation process. This creates the primary long-running `BackgroundJob` with `task_name: 'process_project_entries'`.
2.  **Worker Execution**:
    *   A worker picks up the job and sets the `Project.status` to `processing`.
    *   The worker queries the database for a chunk of `Link` records with `status: 'pending'`.
    *   **For each `Link` in the chunk**:
        a.  It updates the `Link.status` to `processing`.
        b.  It scrapes the content from the `Link.url`, storing the cleaned result in the `Link.raw_content` field.
        c.  It uses the `templates.entry_creation` prompt, providing the `raw_content` to the LLM and requesting a structured JSON response containing `title`, `content`, and `keywords`.
        d.  An `ApiRequestLog` is created for this LLM call.
        e.  On success, it parses the LLM's response, creates a `LorebookEntry` record, and updates the `Link`'s status to `completed` and sets the `lorebook_entry_id`.
        f.  On failure, it updates the `Link`'s `status` to `failed` and records the `error_message`.
    *   After processing a chunk, the worker updates the job's progress and checks for cancellation requests before fetching the next chunk.
3.  **Completion**: Once all `Link` records are processed, the worker updates the `Project.status` to `completed` and marks its own job as `completed`.

#### **4. API Endpoints**

*   **Projects**
    *   `POST /projects`: Create a new lorebook project.
    *   `GET /projects`: List all projects.
    *   `GET /projects/{project_id}`: Retrieve a single project's details.
    *   `PATCH /projects/{project_id}`: Update a project.
    *   `DELETE /projects/{project_id}`: Delete a project.
    *   `GET /projects/{project_id}/links`: Get a paginated list of links for the project.
    *   `GET /projects/{project_id}/entries`: Get a paginated list of generated lorebook entries.
    *   `GET /projects/{project_id}/logs`: Get a paginated list of API request logs for the project.
    *   `GET /projects/{project_id}/lorebook/download`: Get the lorebook in a downloadable format.

*   **Lorebook Entries**
    *   `GET /entries/{entry_id}`: Retrieve a single lorebook entry.
    *   `PUT /entries/{entry_id}`: Manually edit a generated lorebook entry.
    *   `DELETE /entries/{entry_id}`: Delete a lorebook entry.

*   **Background Jobs**
    *   `GET /jobs`: List all background jobs.
    *   `GET /jobs/{job_id}`: Retrieve a single job's status and progress.
    *   `POST /jobs/generate-search-params`: Create a job to generate search parameters from a project's prompt (Workflow A).
    *   `POST /jobs/generate-selector`: Create a job to generate CSS selectors for a project (Workflow B).
    *   `POST /jobs/extract-links`: Create a job to ingest a user-confirmed list of URLs (Workflow C).
    *   `POST /jobs/process-project-entries`: Create a job to process all pending links into lorebook entries (Workflow D).
    *   `POST /jobs/{job_id}/cancel`: Request cancellation of a running job.

*   **Providers**
    *   `GET /providers`: List all available AI providers and their models.

*   **Server-Sent Events (SSE)**
    *   `GET /sse/subscribe/{project_id}`: Subscribe to a stream of real-time events for a project, primarily for job progress updates.

*   **Analytics**
    *   `GET /analytics/projects/{project_id}`: Get aggregated cost and usage statistics for a project.

*   **Global Templates**
    *   `POST /global-templates`: Create a new global template.
    *   `GET /global-templates`: List all global templates.
    *   `GET /global-templates/{template_id}`: Retrieve a single global template.
    *   `PATCH /global-templates/{template_id}`: Update a global template.
    *   `DELETE /global-templates/{template_id}`: Delete a global template.